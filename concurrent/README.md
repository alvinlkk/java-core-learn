# Java并发编程

## 线程互斥（锁）

### 什么是CAS
CAS（Compare Aand Swap）是现代CPU广泛支持的一种对内存中的共享数据进行操作的一种特殊指令。这个指令会对内存中的共享数据做原子的读写操作。
- 操作过程（内存值V, 旧的预期值A， 要修改的值B）
1. CPU将内存值V和旧的预期值A作比较
2. 如果V和A的值相同，CPU会将内存中的值改为B,否则什么都不做。
3. 最后，CPU将旧的值返回。

### 为什么需求要锁
在多用户环境中，同一时间会有多个用户更新相同的记录，产生冲突。这就是并发性问题。
- 丢失更新
- 脏读： 如用户A,B同时读取值为1，用户A把值改为2，用户A读到的仍是1.

### 什么是乐观锁和悲观锁
- 悲观锁：假定会发生并发冲突，独占锁，屏蔽一切可能违反数据完整性的操作。
- 乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。乐观锁不能解决数据脏读的问题。

## 线程之间的协作
### join
在线程中调用另一个线程的join方法，会将当前线程挂起，知道目标线程结束。


### wait() notify() notifyAll()
- 通过wait notify 控制线程的执行顺序，wait让线程挂起，notify唤醒挂起的线程。
- 属于Object的方法
- 只能用在同步方法或者同步控制块中使用！否则会在运行时抛出 IllegalMonitorStateExeception。

### await() signal() signalAll()
- 通过juc的Condition实现线程之间的协调，更加灵活。

### sleep和wait区别
- sleep是Thread类的静态方法。 wait是Object的方法。
- wait会释放锁，sleep不会。
- sleep将执行机会让给其他线程，依旧持有锁，休眠结束会进入就绪状态。wait挂其当前线程，释放锁，需要notify来唤醒进入就绪状态。


# 阻塞队列
